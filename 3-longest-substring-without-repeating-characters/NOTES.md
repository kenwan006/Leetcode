-  We need to use a sliding window
-  We can use start and end index to represent [i, j] a sliding window. Eg: we have a string "abcadgf", the current sliding window covers "abc" with the length of 3. (We can use a hashmap to store all the distinct characters within the window). Then we check the next one, since the character 'a' is aleady in the current sliding window, so we have to reset the sliding window starting 'b',. And we can find the window would include 'bcadg' with the length of 6, which is greater the existing number 3, so we have to update the maxium length of the longest substring.
- Attention, the new start index should be greater than the start index of current sliding window. For example, we have a string 'gaabcagd', when the slide window come to 'bca', the start index of this window is 'b' at index 3, we check next element 'g', but found this element  is alraedy at index 0. But since it's smaller than 3, we can't use 0 as the start of new sliding window. Instead we add 'g' indexed at 7 to the existing sliding window.
start = max{start, map.get('g')}